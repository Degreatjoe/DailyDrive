#!/usr/bin/python3
# Generated by CodiumAI
from unittest import mock
from models.engine.db_storage import DBStorage
from models.base_model import BaseModel, Base
import unittest


class TestDBStorage(unittest.TestCase):

    # Initialize DBStorage and create engine with correct MySQL credentials
    def test_initialize_db_storage_with_correct_credentials(self):
        with mock.patch.dict('os.environ', {
            'DD_MYSQL_USER': 'test_user',
            'DD_MYSQL_PWD': 'test_password',
            'DD_MYSQL_HOST': 'localhost',
            'DD_MYSQL_DB': 'test_db'
        }):
            storage = DBStorage()
            self.assertIsNotNone(storage._DBStorage__engine)
            self.assertIn('mysql+mysqldb://test_user:test_password@localhost/test_db', str(storage._DBStorage__engine.url))

    # Initialize DBStorage with missing or incorrect MySQL credentials
    def test_initialize_db_storage_with_incorrect_credentials(self):
        with mock.patch.dict('os.environ', {
            'DD_MYSQL_USER': '',
            'DD_MYSQL_PWD': '',
            'DD_MYSQL_HOST': '',
            'DD_MYSQL_DB': ''
        }):
            with self.assertRaises(Exception):
                DBStorage()

    # Add new object to session and commit changes
    def test_add_object_and_commit_changes(self):
        with mock.patch.dict('os.environ', {
            'DD_MYSQL_USER': 'test_user',
            'DD_MYSQL_PWD': 'test_password',
            'DD_MYSQL_HOST': 'localhost',
            'DD_MYSQL_DB': 'test_db'
        }):
            storage = DBStorage()
            storage.reload()

            obj = mock.Mock()
            obj.__class__.__name__ = 'TestModel'
            obj.id = 1
            storage.new(obj)
            storage.save()
            obj_id = f"TestModel.{obj.id}"
            self.assertIn(obj_id, storage.all())

    # Retrieve all objects from the database as a dictionary
    def test_retrieve_all_objects_as_dictionary(self):
        with mock.patch.dict('os.environ', {
            'DD_MYSQL_USER': 'test_user',
            'DD_MYSQL_PWD': 'test_password',
            'DD_MYSQL_HOST': 'localhost',
            'DD_MYSQL_DB': 'test_db'
        }):
            storage = DBStorage()
            storage.reload()
            test_obj = mock.Mock()
            test_obj.__class__.__name__ = 'TestModel'
            test_obj.id = 1
            storage.new(test_obj)
            storage.save()
            all_objs = storage.all()
            self.assertEqual(len(all_objs), 1)

    # Delete a specific object from the session and commit changes
    def test_delete_object_and_commit_changes(self):
        with mock.patch.dict('os.environ', {
            'DD_MYSQL_USER': 'test_user',
            'DD_MYSQL_PWD': 'test_password',
            'DD_MYSQL_HOST': 'localhost',
            'DD_MYSQL_DB': 'test_db'
        }):
            storage = DBStorage()
            storage.reload()

            # Create a sample object and add it to the session
            obj = mock.Mock()
            obj.__class__.__name__ = 'TestModel'
            obj.id = 1
            storage.new(obj)
            storage.save()

            # Delete the object and commit changes
            storage.delete(obj)
            storage.save()

            # Check if the object is deleted
            all_objs = storage.all()
            self.assertNotIn(f"TestModel.{obj.id}", all_objs)

    # Reload database tables and create a new session
    def test_reload_database_tables_and_create_session(self):
        with mock.patch.dict('os.environ', {
            'DD_MYSQL_USER': 'test_user',
            'DD_MYSQL_PWD': 'test_password',
            'DD_MYSQL_HOST': 'localhost',
            'DD_MYSQL_DB': 'test_db'
        }):
            storage = DBStorage()
            storage.reload()
            self.assertIsNotNone(storage._DBStorage__engine)
            self.assertIsNotNone(storage._DBStorage__session)

    # Retrieve all objects when no objects exist in the database
    def test_retrieve_all_objects_no_objects_exist(self):
        with mock.patch.dict('os.environ', {
            'DD_MYSQL_USER': 'test_user',
            'DD_MYSQL_PWD': 'test_password',
            'DD_MYSQL_HOST': 'localhost',
            'DD_MYSQL_DB': 'test_db'
        }):
            storage = DBStorage()
            storage.reload()
            result = storage.all()
            self.assertEqual(result, {})

    # Add a new object to the session without committing changes
    def test_add_new_object_to_session(self):
        with mock.patch.dict('os.environ', {
            'DD_MYSQL_USER': 'test_user',
            'DD_MYSQL_PWD': 'test_password',
            'DD_MYSQL_HOST': 'localhost',
            'DD_MYSQL_DB': 'test_db'
        }):
            storage = DBStorage()
            storage.reload()
            mock_obj = mock.Mock()
            storage.new(mock_obj)
            self.assertIn(mock_obj, storage._DBStorage__session.new)

    # Delete a non-existent object from the session
    def test_delete_non_existent_object(self):
        with mock.patch('sqlalchemy.orm.session.Session.delete') as mock_delete:
            storage = DBStorage()
            storage.reload()
            obj = None  # Non-existent object
            storage.delete(obj)
            mock_delete.assert_not_called()

    # Reload database tables when the database is empty
    def test_reload_database_tables_when_empty(self):
        with mock.patch.dict('os.environ', {
            'DD_MYSQL_USER': 'test_user',
            'DD_MYSQL_PWD': 'test_password',
            'DD_MYSQL_HOST': 'localhost',
            'DD_MYSQL_DB': 'test_db'
        }):
            with mock.patch('sqlalchemy.create_engine') as mock_create_engine, \
                 mock.patch('sqlalchemy.orm.sessionmaker') as mock_sessionmaker, \
                 mock.patch('sqlalchemy.orm.scoped_session') as mock_scoped_session, \
                 mock.patch('models.base_model.Base.metadata.create_all') as mock_create_all:
                
                storage = DBStorage()
                storage.reload()

                mock_create_engine.assert_called_once_with(
                    'mysql+mysqldb://test_user:test_password@localhost/test_db',
                    pool_pre_ping=True
                )
                mock_create_all.assert_called_once_with(storage._DBStorage__engine)
                mock_sessionmaker.assert_called_once_with(bind=storage._DBStorage__engine, expire_on_commit=False)
                mock_scoped_session.assert_called_once_with(mock_sessionmaker.return_value)

    # Handle environment variable 'DD_ENV' set to 'test' and drop all tables
    def test_handle_dd_env_test_drop_all_tables(self):
        with mock.patch.dict('os.environ', {'DD_ENV': 'test'}):
            with mock.patch('sqlalchemy.create_engine') as mock_create_engine:
                with mock.patch('sqlalchemy.MetaData.drop_all') as mock_drop_all:
                    storage = DBStorage()
                    mock_drop_all.assert_called_once()

    # Verify that 'reload' method imports all models correctly
    def test_reload_imports_all_models_correctly(self):
        with mock.patch('models.state') as mock_state, \
             mock.patch('models.city') as mock_city, \
             mock.patch('models.amenity') as mock_amenity, \
             mock.patch('models.place') as mock_place, \
             mock.patch('models.review') as mock_review:
        
            storage = DBStorage()
            storage.reload()
        
            mock_state.assert_called_once()
            mock_city.assert_called_once()
            mock_amenity.assert_called_once()
            mock_place.assert_called_once()
            mock_review.assert_called_once()

    # Handle case where 'cls' parameter is None in the 'all' method
    def test_handle_none_cls_parameter_in_all_method(self):
        with mock.patch('models.engine.db_storage.DBStorage._DBStorage__session') as mock_session:
            db_storage = DBStorage()
            db_storage._DBStorage__session = mock_session
            db_storage.all(cls=None)
            mock_session.query.assert_called_with(BaseModel)

    # Ensure session is None before reloading tables
    def test_reload_session_none(self):
        with mock.patch.dict('os.environ', {
            'DD_ENV': 'test'
        }):
            storage = DBStorage()
            storage.reload()
            self.assertIsNone(storage._DBStorage__session)

    # Query objects using class name as a string
    def test_query_objects_by_class_name(self):
        with mock.patch.dict('os.environ', {
            'DD_MYSQL_USER': 'test_user',
            'DD_MYSQL_PWD': 'test_password',
            'DD_MYSQL_HOST': 'localhost',
            'DD_MYSQL_DB': 'test_db',
            'DD_ENV': 'test'
        }):
            with mock.patch('sqlalchemy.create_engine') as mock_create_engine:
                with mock.patch('sqlalchemy.orm.sessionmaker') as mock_sessionmaker:
                    with mock.patch('sqlalchemy.orm.scoped_session') as mock_scoped_session:
                        storage = DBStorage()
                        storage.reload()
                        storage._DBStorage__session = mock.Mock()

                        # Create a test object
                        test_obj = mock.Mock()
                        test_obj.id = 1
                        test_obj.__class__.__name__ = 'TestModel'

                        # Add the test object to the session
                        storage.new(test_obj)
                        storage.save()

                        # Query objects by class name
                        result = storage.all('TestModel')

                        self.assertEqual(len(result), 1)


if __name__ == '__main__':
    unittest.main()
